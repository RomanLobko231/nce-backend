package com.nce.backend.auction.domain.entities;

import com.nce.backend.auction.domain.valueObjects.AuctionStatus;
import com.nce.backend.auction.domain.valueObjects.AutoBid;
import com.nce.backend.auction.domain.valueObjects.Bid;
import com.nce.backend.auction.domain.valueObjects.CarDetails;
import com.nce.backend.auction.exceptions.AuctionClosedException;
import com.nce.backend.auction.exceptions.InvalidBidException;
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

@Builder
@Getter
@Setter
public class Auction {
    private UUID id;

    private BigDecimal startingPrice;

    private BigDecimal minimalStep;

    private BigDecimal expectedPrice;

    private Bid highestBid;

    private Instant endDateTime;

    private CarDetails carDetails;

    @Builder.Default
    private List<Bid> bids = new ArrayList<>();

    @Builder.Default
    private List<AutoBid> autoBids = new ArrayList<>();

    private AuctionStatus status;

    public void placeNewBid(Bid bid) {
        this.checkAuctionAvailability();
        this.validateBid(bid);

        // Extend auction time by 2 minutes due to last-minute bids
        if (Duration.between(Instant.now(), endDateTime).toMinutes() < 10) {
            endDateTime = endDateTime.plus(2, ChronoUnit.MINUTES);
        }

        bid.setPlacedAt(Instant.now());
        bids.add(bid);
        highestBid = bid;
    }

    public void placeNewAutoBid(AutoBid autoBid) {
        this.validateAutoBid(autoBid);

        autoBid.setPlacedAt(Instant.now());
        autoBids.add(autoBid);

        if (highestBid == null) {
            Bid bid = Bid
                    .builder()
                    .bidderId(autoBid.getBidderId())
                    .auctionId(this.getId())
                    .amount(startingPrice)
                    .isAutoGenerated(true)
                    .build();

            this.placeNewBid(bid);
        }
    }

    private void validateBid(Bid bid) {
        if (bid == null) {
            throw new InvalidBidException("Bid cannot be null");
        }

        BigDecimal minAcceptableAmount = bids.isEmpty()
                ? startingPrice
                : highestBid.getAmount().add(minimalStep);

        if (bid.getAmount().compareTo(minAcceptableAmount) < 0) {
            throw new InvalidBidException("Bid is too low. Must be at least %.2f".formatted(minAcceptableAmount));
        }

//        if (highestBid != null && bid.getBidderId().equals(highestBid.getBidderId())) {
//            throw new InvalidBidException("You are already the highest bidder. No need to bid again.");
//        }

        if (!bid.isAutoGenerated()) {
            boolean matchesAutoBid = autoBids
                    .stream()
                    .anyMatch(autoBid -> autoBid.getLimitAmount().compareTo(bid.getAmount()) == 0);

            if (matchesAutoBid) {
                throw new InvalidBidException(
                        "An auto bid with the amount '%.2f' exists already. Can't place a bid with the exact same amount"
                                .formatted(bid.getAmount())
                );
            }
        }

    }

    private void validateAutoBid(AutoBid autoBid) {
        if (autoBid == null) {
            throw new InvalidBidException("Auto Bid cannot be null");
        }

        BigDecimal minAcceptableAmount = bids.isEmpty()
                ? startingPrice
                : highestBid.getAmount().add(minimalStep.multiply(BigDecimal.valueOf(2L)));

        if (autoBid.getLimitAmount().compareTo(minAcceptableAmount) < 0) {
            throw new InvalidBidException(
                    "Auto Bid is too low. Must be at least %.2f".formatted(minAcceptableAmount)
            );
        }
    }

    public void checkAuctionAvailability() {
        if (Instant.now().isAfter(endDateTime) ||
                this.status == AuctionStatus.FINISHED) {
            throw new AuctionClosedException("Auction is already closed. Cannot place new bid.");
        }
        if (this.status == AuctionStatus.DISABLED) {
            throw new AuctionClosedException("Auction is currently paused.");
        }
    }

    public void applyChangesFrom(Auction auction) {
        if (auction == null || auction.getId() == null) {
            throw new IllegalArgumentException("Auction cannot be null");
        }

        if (auction.getEndDateTime() != null) this.endDateTime = auction.getEndDateTime();
        if (auction.getCarDetails() != null) this.carDetails = auction.getCarDetails();
        if (auction.getExpectedPrice() != null) this.expectedPrice = auction.getExpectedPrice();
        if (auction.getMinimalStep() != null) this.minimalStep = auction.getMinimalStep();
        if (auction.getStartingPrice() != null) this.startingPrice = auction.getStartingPrice();
    }


    public void triggerAutoBids() {
        boolean placed;
        do {
            placed = false;

            Optional<AutoBid> nextAutoBid = autoBids
                    .stream()
                    .filter(autoBid -> autoBid
                            .getLimitAmount()
                            .compareTo(highestBid.getAmount().add(minimalStep)) >= 0)
                    .filter(autoBid -> !autoBid
                            .getBidderId()
                            .equals(highestBid.getBidderId()))
                    .sorted(
                            Comparator
                                    .comparing(AutoBid::getLimitAmount)
                                    .thenComparing(AutoBid::getPlacedAt)
                    )
                    .findFirst();

            List<AutoBid> eligebleBids = autoBids
                    .stream()
                    .filter(autoBid -> autoBid
                            .getLimitAmount()
                            .compareTo(highestBid.getAmount().add(minimalStep)) >= 0)
                    .sorted(
                            Comparator
                                    .comparing(AutoBid::getLimitAmount)
                                    .thenComparing(AutoBid::getPlacedAt)
                    )
                    .toList();

            if (nextAutoBid.isPresent() && nextAutoBid.get().getLimitAmount().compareTo(highestBid.getAmount().add(minimalStep)) == 0) {
                if (eligebleBids.size() > 1 && eligebleBids.get(0).getLimitAmount().compareTo(eligebleBids.get(1).getLimitAmount()) == 0) {
                    if (eligebleBids.get(1).equals(nextAutoBid.get())) {
                        placeNewBid(Bid
                                .builder()
                                .amount(highestBid.getAmount().add(minimalStep))
                                .auctionId(id)
                                .bidderId(eligebleBids.get(0).getBidderId())
                                .isAutoGenerated(true)
                                .build());
                        break;
                    }
                }
            }


            if (nextAutoBid.isPresent()) {
                placeNewBid(Bid
                        .builder()
                        .amount(highestBid.getAmount().add(minimalStep))
                        .auctionId(id)
                        .bidderId(nextAutoBid.get().getBidderId())
                        .isAutoGenerated(true)
                        .build());
                placed = true;
            }

        } while (placed);
    }

    public void restartWithNewData(Auction newAuctionData) {
        if (newAuctionData.getEndDateTime().isBefore(Instant.now())) {
            throw new IllegalStateException(
                    "New end date should be in future. Your is '%s'".formatted(newAuctionData.getEndDateTime().toString())
            );
        }
        if (this.status == AuctionStatus.ACTIVE) {
            throw new IllegalStateException("Cannot restart. Auction has already been started");
        }

        applyChangesFrom(newAuctionData);
        this.status = AuctionStatus.ACTIVE;
    }

}
